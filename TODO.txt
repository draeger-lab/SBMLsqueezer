TODO-Liste
==========

Edukt- und Produktlisten kï¿½nnen leer sein. Dieser Spezialfall wird bisher
nicht in den einzelnen Kinetiken behandelt.

Hier wird an vielen Stellen von einer Stï¿½chiometrie ausgegangen.
Es kï¿½nnen aber auch komplexe Ausdrï¿½cke vorkommen. Diesen muss
Rechnung getragen werden.

Problem mit logischen UND, ODER etc.

In Hill-Kinetik dafï¿½r sorgen, dass nicht mit der Gen-Konzentration
multipliziert und der Parameter Ks nicht mit dem Hill-Koeffizienten
potenziert wird (sonst Probleme mit Einheiten).

Direkt am Vorschaufenster fï¿½r kinetische Gleichungen kï¿½nnte ein Knopf
sein, mit dem die Gleichung nach LaTeX oder Text gespeichert werden
kï¿½nnte.

Bug erkannt im CellDesigner: Im Biomodell 5 verschwindet bei Anwendung
der Liebermeister-Kinetiken der Parameter R fï¿½r die Gaskonstante.

Problem in jsbml: ï¿½nderungen an CVTerms kï¿½nnen nicht richtig mit libSBML
synchronisiert werden.

Probleme mit UTF-8 in jsbml: libSBML-Parser wandeln alle Zeichen in
UTF-8 um. Beim Synchronisieren mï¿½ssen Sonderzeichen wieder zu den Zeichen-
Codes ï¿½bersetzt werden.

Wenn existierende Kinetik ausgewï¿½hlt wird, so darf der Schalter fÃ¼r Enzym-
Kinetik nicht verÃ¤nderbar sein.

Offenbar hat SBML2LaTeX ein Problem mit Constraints. Vermutlich lÃ¶sen die
einen Programmabsturz aus.

MÃ¶glicherweise werden globale Parameter nicht gelÃ¶scht, wenn es lokale
Parameter mit identischer ID gibt, die in kinetischen Gleichungen vorkommen.
Das sollte aber nicht passieren. Es mÃ¼sste eben Ã¼berprÃ¼ft werden, ob ein
Parameter mit einer bestimmten ID, der in einer kinetischen Gleichung 
referenziert wird, auch nochmal als lokaler Parameter in dieser Gleichung 
vorkommt.


SBMLsimulator: Probleme bei der Simulation von Test-Suite-Modellen
==================================================================

Modell 164 konnte nicht simuliert werden. Ewig lange Rechenzeit.

instabile Modelle:
57, 132, 204, 389, 392, 395, 446, 449, 452, 523, 524, 525, 566, 595,
831
=> Frage: warum?

GroÃŸe Abweichung zwischen Simulation und gegebenen Werten bei Modellen:
058, 059, 133, 134, 158, 328, 329, 330, 356, 369, 370, 371, 372, 373, 374, 
397, 398, 402, 404, 453, 454, 455, 459, 460, 461, 526, 531, 533, 534, 535,
536, 537, 538, 541, 543, 546, 548, 549, 550, 551, 552, 553, 554, 555, 556,
557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571,
572, 573, 574, 575, 576, 586, 587, 588, 596, 597, 601, 602, 603, 604, 605,
606, 607, 608, 611, 612, 613, 614, 615, 628, 629, 630, 658, 659, 661, 662,
663, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678,
679, 680, 681, 682, 683, 684, 685, 686, 687, 689, 690, 695, 696, 697, 703,
704, 705, 707, 708, 709, 710, 715, 716, 732, 733, 734, 736, 738, 739, 740,
741, 742, 743, 744, 745, 746, 747, 748, 750, 763, 764, 765, 766, 767, 768,
769, 770, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 815,
816, 817, 830, 844, 860, 861, 862, 870, 871, 872, 874, 875, 876, 884, 891,
892, 893, 896, 897, 900, 903

Modelle mit algebraischen Regeln:
39, 40, 531, 536, 537, 538, 541, 543, 548, 549, 550, 551, 552, 553, 554, 555,
556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571,
572, 573, 574, 575, 576, 628, 695, 696, 759, 760, 761, 762

Crash in Modellen:
759, 760, 761, 762

Modelle 203 und 204 vom Aufbau her gleich, aber die Simulation von 204
liefert nur das richtige Ergebniss, wenn die Quadratwurzel des Compartiments verrechnet
wird anstelle nur der normale Wert des Compartiments.
Das gleiche gilt fÃ¼r 373 und 374

Modell 870 bis 875, es gibt Reaktionen mit fast=true => ungenau Simulation, da diese
Eigenschaft noch nicht berÃ¼cksichtigt wird


Im Plot-Dialog:
- Farbzuordnung der Kurven zu Kreuzen klappt nicht richtig. 
  Besonders auffÃ¤llig bei Modell 54, 55, 56, 161
- Berechnung der Fehlerfunktion darf nur fÃ¼r die Variablen Teile erfolgen.
- FÃ¼r das Kompartiment in Modell 104 werden die Punkte nicht geplottet.
- In Modell 112 werden die Punkte fÃ¼r S1 nicht geplottet.


Allgemeine Probleme
===================

1) die Methode getIndex scheint nicht richtig zu funktionieren,
wenn ich von einem Knoten n den Elter hole und prüfe ob dieser Elter den Knoten
n enthält(was der Fall sein müsste), bekomme ich trotzdem nicht den richtigen 
Index bzw. -1. Im Debugger konnte ich sehen, dass er bei (node.equals(n)) 
einmal 2 Knoten mit der gleichen Id, d.h. einen Knoten mit sich selbst vergleich, 
der Test aber false auswertet. Wenn ich (node.equals(n)) auf == ändere funktioniert 
es. Allerdings gab es auch Fälle, bei denen die Methode trotzdem funktioniert hat.

2) die Methode node.removeChild(i) stellt mich auch vor ein Rätsel.
Ich kann die Methode mit Indizes ausführen, die es garnicht gibt. Auch -1 
wirft keine Fehler. Und bei den gültigen Indizes hat sie keine Auswirkung 

- Der Progress-Dialog verschwindet manchmalnicht. Beispielsweise 
  fÃ¼r Testmodell 109

Events mit delay kÃ¶nnen aufgrund der Schrittweite zu spÃ¤t verarbeitet werden

Offenbar funktionieren weder die Online-Hilfe noch die Software-Lizenz.

Model 658: Wenn man versucht, eine Kinetik fÃ¼r die Reaktion zu erzeugen, 
kommt eine NullPointerException. Was ist da los?